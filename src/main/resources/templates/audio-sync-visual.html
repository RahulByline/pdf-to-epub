<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Sync - Advanced Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Top Header */
        .top-header {
            background: white;
            padding: 12px 20px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .page-selector {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .page-selector select {
            padding: 6px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .header-right {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #8b7fa8;
            color: white;
        }

        .btn-primary:hover {
            background: #7a6f98;
        }

        .btn-secondary {
            background: #f5f5f5;
            color: #666;
        }

        /* Main Content - Side by Side */
        .main-editor {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        /* Left Sidebar - Pages List */
        .left-sidebar {
            width: 250px;
            background: white;
            border-right: 1px solid #e0e0e0;
            overflow-y: auto;
            padding: 15px;
        }

        .sidebar-header {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e0e0e0;
        }

        .sidebar-header h3 {
            font-size: 14px;
            color: #333;
        }

        .page-item {
            background: #f9f9f9;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .page-item:hover {
            border-color: #8b7fa8;
        }

        .page-item.active {
            border-color: #8b7fa8;
            background: #f0f0ff;
        }

        .page-thumbnail {
            width: 100%;
            height: 80px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 6px;
            overflow: hidden;
        }

        .page-thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .page-number {
            font-size: 12px;
            font-weight: 600;
            color: #333;
        }

        /* PDF Canvas - Left Panel */
        .pdf-canvas-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #fafafa;
            border-right: 1px solid #e0e0e0;
            overflow: hidden;
        }

        .panel-header {
            background: white;
            padding: 10px 15px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-header h4 {
            font-size: 14px;
            color: #333;
        }

        .text-selection-mode {
            background: #4caf50 !important;
            color: white !important;
        }

        .text-selection-mode:hover {
            background: #45a049 !important;
        }

        .selection-rectangle {
            position: absolute;
            border: 2px dashed #4caf50;
            background: rgba(76, 175, 80, 0.1);
            pointer-events: none;
            z-index: 100;
        }

        .selected-text-segment {
            position: absolute;
            background: rgba(255, 193, 7, 0.3);
            border: 2px solid #ffc107;
            border-radius: 4px;
            padding: 4px 8px;
            z-index: 15;
            cursor: pointer;
        }

        .selected-text-segment:hover {
            background: rgba(255, 193, 7, 0.5);
            border-color: #ff9800;
        }

        .custom-segment-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .custom-segment-modal.active {
            display: flex;
        }

        .custom-segment-content {
            background: white;
            border-radius: 8px;
            padding: 20px;
            max-width: 600px;
            width: 90%;
        }

        .selected-text-preview {
            background: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            margin: 15px 0;
            max-height: 200px;
            overflow-y: auto;
            font-size: 14px;
            line-height: 1.6;
        }

        .pdf-canvas-container {
            flex: 1;
            overflow: auto;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }

        .pdf-page-container {
            position: relative;
            display: inline-block;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .pdf-page-image {
            max-width: 100%;
            height: auto;
            display: block;
        }

        .text-block-overlay {
            position: absolute;
            padding: 4px 8px;
            background: rgba(33, 150, 243, 0.2);
            border: 2px solid rgba(33, 150, 243, 0.6);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 10;
        }

        .text-block-overlay:hover {
            background: rgba(33, 150, 243, 0.4);
            border-color: rgba(33, 150, 243, 1);
            box-shadow: 0 4px 8px rgba(33, 150, 243, 0.4);
            transform: scale(1.02);
        }

        .text-block-overlay.selected {
            background: rgba(76, 175, 80, 0.4);
            border-color: #4caf50;
            border-width: 3px;
            z-index: 20;
        }

        .text-block-overlay.synced {
            background: rgba(33, 150, 243, 0.4);
            border-color: #2196f3;
        }

        /* XHTML Preview - Right Panel */
        .xhtml-preview-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #fafafa;
            overflow: hidden;
        }

        .xhtml-preview-container {
            flex: 1;
            overflow: auto;
            padding: 20px;
        }

        .xhtml-content {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
        }

        .xhtml-block {
            margin: 10px 0;
            padding: 10px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            background: #f9f9f9;
        }

        .xhtml-block.selected {
            border-color: #4caf50;
            background: #e8f5e9;
        }

        .block-tag {
            display: inline-block;
            padding: 2px 8px;
            background: #8b7fa8;
            color: white;
            border-radius: 3px;
            font-size: 11px;
            margin-right: 8px;
            cursor: pointer;
        }

        .block-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .action-btn {
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 3px;
            background: white;
            cursor: pointer;
            font-size: 11px;
        }

        .action-btn:hover {
            background: #f5f5f5;
        }

        /* Audio Waveform - Bottom Panel */
        .audio-waveform-panel {
            height: 200px;
            background: white;
            border-top: 2px solid #e0e0e0;
            display: flex;
            flex-direction: column;
        }

        .waveform-header {
            padding: 8px 15px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .waveform-container {
            flex: 1;
            position: relative;
            overflow-x: auto;
            overflow-y: hidden;
            background: #1a1a1a;
        }

        .waveform-canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .segment-boundary {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #4caf50;
            cursor: ew-resize;
            z-index: 10;
        }

        .segment-boundary:hover {
            background: #66bb6a;
            width: 3px;
        }

        .segment-boundary.start {
            background: #2196f3;
        }

        .segment-boundary.end {
            background: #f44336;
        }

        .segment-label {
            position: absolute;
            top: 5px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            pointer-events: none;
        }

        /* Audio Controls */
        .audio-controls {
            padding: 10px 15px;
            border-top: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .play-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: #8b7fa8;
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .time-display {
            font-size: 12px;
            color: #666;
            min-width: 100px;
        }

        .progress-bar {
            flex: 1;
            height: 4px;
            background: #e0e0e0;
            border-radius: 2px;
            position: relative;
            cursor: pointer;
        }

        .progress-fill {
            height: 100%;
            background: #8b7fa8;
            border-radius: 2px;
            width: 0%;
        }

        /* Edit Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 8px;
            padding: 20px;
            max-width: 500px;
            width: 90%;
        }

        .modal-header {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e0e0e0;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 13px;
            color: #333;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }

        audio {
            display: none;
        }

        @keyframes pulse {
            0%, 100% { background: #fff3e0; }
            50% { background: #ffe0b2; }
        }

        .xhtml-block {
            margin-bottom: 20px;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            background: white;
            transition: all 0.3s;
        }

        .xhtml-block:hover {
            border-color: #b0bec5;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .xhtml-block.selected {
            border-color: #2196f3;
            background: #e3f2fd;
            box-shadow: 0 4px 12px rgba(33, 150, 243, 0.3);
        }
    </style>
</head>
<body>
    <!-- Top Header -->
    <div class="top-header">
        <div class="header-left">
            <div class="page-selector">
                <label>Page:</label>
                <select id="pageSelect"></select>
            </div>
            <span id="currentPageInfo">Page 1 of 16</span>
        </div>
        <div class="header-right">
            <div style="display: flex; align-items: center; gap: 10px;">
                <label style="font-size: 12px; color: #666;">Voice:</label>
                <select id="voiceSelect" style="padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;" onchange="updateVoicePreference()">
                    <option value="default">Default</option>
                    <option value="kid-friendly" selected>Kid-Friendly</option>
                    <option value="child">Child Voice</option>
                    <option value="young">Young Voice</option>
                </select>
            </div>
            <button class="btn btn-secondary" onclick="reRunAlignment()">Re-run Alignment</button>
            <button class="btn btn-primary" onclick="saveAllChanges()">Save All Changes</button>
        </div>
    </div>

    <!-- Main Editor - Side by Side -->
    <div class="main-editor">
        <!-- Left Sidebar - Pages -->
        <div class="left-sidebar">
            <div class="sidebar-header">
                <h3>All Pages</h3>
            </div>
            <div id="pagesList"></div>
        </div>

        <!-- PDF Canvas - Left -->
        <div class="pdf-canvas-panel">
            <div class="panel-header">
                <h4>PDF Canvas</h4>
                <div style="display: flex; gap: 8px;">
                    <button class="btn btn-secondary" onclick="toggleHighlightMode()">Toggle Highlights</button>
                    <span style="font-size: 12px; color: #666; align-self: center; padding: 0 10px;">
                        Click and drag to select text, or click text blocks to sync
                    </span>
                </div>
            </div>
            <div class="pdf-canvas-container" id="pdfCanvasContainer">
                <p style="text-align: center; color: #999; padding: 40px;">Loading PDF page...</p>
            </div>
        </div>

        <!-- XHTML Preview - Right -->
        <div class="xhtml-preview-panel">
            <div class="panel-header">
                <h4>XHTML Preview</h4>
                <button class="btn btn-secondary" onclick="toggleXhtmlView()">Toggle View</button>
            </div>
            <div class="xhtml-preview-container" id="xhtmlPreviewContainer">
                <p style="text-align: center; color: #999; padding: 40px;">Select a page to view XHTML</p>
            </div>
        </div>
    </div>

    <!-- Audio Waveform - Bottom -->
    <div class="audio-waveform-panel">
        <div class="waveform-header">
            <h4>Audio Waveform</h4>
            <div class="audio-controls">
                <button class="play-btn" id="playBtn">â–¶</button>
                <button class="btn btn-secondary" id="markStartBtn" onclick="markStartTime()" title="Mark Start Time (S)">Mark Start</button>
                <button class="btn btn-secondary" id="markEndBtn" onclick="markEndTime()" title="Mark End Time (E)">Mark End</button>
                <div class="time-display" id="timeDisplay">0:00 / 0:00</div>
                <div class="progress-bar" id="progressBar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>
        </div>
        <div class="waveform-container" id="waveformContainer">
            <canvas class="waveform-canvas" id="waveformCanvas"></canvas>
        </div>
    </div>

    <!-- Edit Modal -->
    <div class="modal" id="editModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modalTitle">Edit Block</h3>
            </div>
            <div id="modalBody">
                <div class="form-group">
                    <label>Block Tag:</label>
                    <select id="blockTagSelect">
                        <option value="p">Paragraph (p)</option>
                        <option value="h1">Heading 1 (h1)</option>
                        <option value="h2">Heading 2 (h2)</option>
                        <option value="h3">Heading 3 (h3)</option>
                        <option value="exercise">Exercise</option>
                        <option value="span">Span</option>
                        <option value="div">Div</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Alt Text:</label>
                    <textarea id="altTextInput" rows="3"></textarea>
                </div>
                <div class="form-group">
                    <label>Text Content:</label>
                    <textarea id="textContentInput" rows="4"></textarea>
                </div>
            </div>
            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
                <button class="btn btn-primary" onclick="saveBlockEdit()">Save</button>
            </div>
        </div>
    </div>

    <!-- Custom Text Selection Modal -->
    <div class="custom-segment-modal" id="customSegmentModal">
        <div class="custom-segment-content">
            <div class="modal-header">
                <h3>Create Audio Sync for Selected Text</h3>
            </div>
            <div>
                <label style="display: block; margin-bottom: 8px; font-weight: 500;">Selected Text:</label>
                <div class="selected-text-preview" id="selectedTextPreview"></div>
                <div class="form-group" style="margin-top: 15px;">
                    <label>Segment Name (optional):</label>
                    <input type="text" id="segmentNameInput" placeholder="e.g., Paragraph 1, Introduction" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                </div>
            </div>
            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="closeCustomSegmentModal()">Cancel</button>
                <button class="btn btn-primary" onclick="createCustomTextSegment()">Create Segment</button>
            </div>
        </div>
    </div>

    <audio id="audioPlayer"></audio>

    <script>
        let jobId = null;
        let pdfId = null;
        let audioUrl = null;
        let pagesData = [];
        let currentPageIndex = -1;
        let selectedBlockId = null;
        let audioSyncs = [];
        let audioPlayer = null;
        let waveformCanvas = null;
        let waveformCtx = null;
        let editLog = [];
        let voicePreference = 'kid-friendly'; // Default to kid-friendly voice
        let audioContext = null;
        let audioBuffer = null;
        let waveformData = null;
        
        // Text selection mode variables (always enabled)
        let isSelecting = false;
        let selectionStart = null;
        let selectionRectangle = null;
        let customTextSegments = []; // Store custom text segments

        // Get job ID from URL
        const pathParts = window.location.pathname.split('/');
        jobId = pathParts[pathParts.length - 1];

        async function loadData() {
            try {
                // Load job and PDF info
                const jobResponse = await fetch(`/api/conversions/${jobId}`);
                const job = await jobResponse.json();
                pdfId = job.pdfDocumentId;

                // Load XHTML pages from EPUB
                const xhtmlResponse = await fetch(`/api/audio-sync/job/${jobId}/xhtml-pages`);
                if (xhtmlResponse.ok) {
                    const xhtmlResult = await xhtmlResponse.json();
                    pagesData = xhtmlResult.pages || [];
                    
                    if (xhtmlResult.audioUrl) {
                        audioUrl = xhtmlResult.audioUrl;
                    }
                }

                // If audio URL not found, try PDF endpoint
                if (!audioUrl) {
                    const pdfResponse = await fetch(`/api/pdfs/${pdfId}`);
                    const pdf = await pdfResponse.json();
                    audioUrl = pdf.audioFilePath ? `/api/pdfs/${pdfId}/audio` : null;
                }

                if (!audioUrl) {
                    alert('No audio file associated with this PDF.');
                    return;
                }

                // Set up audio player
                audioPlayer = document.getElementById('audioPlayer');
                audioPlayer.src = audioUrl;
                audioPlayer.addEventListener('timeupdate', () => {
                    updateTimeDisplay();
                    updateWaveformPlaybackPosition();
                });
                audioPlayer.addEventListener('loadedmetadata', () => {
                    updateTimeDisplay();
                    initializeWaveform();
                    loadAudioForWaveform();
                });

                // Load existing syncs
                const syncsResponse = await fetch(`/api/audio-sync/pdf/${pdfId}/job/${jobId}`);
                audioSyncs = await syncsResponse.json();
                
                // Load voice preference from localStorage
                const savedVoice = localStorage.getItem('audioSyncVoicePreference');
                if (savedVoice) {
                    voicePreference = savedVoice;
                    document.getElementById('voiceSelect').value = savedVoice;
                }
                
                // Restore custom segments from syncs
                customTextSegments = [];
                audioSyncs.forEach(sync => {
                    if (sync.isCustomSegment && sync.customText) {
                        // Try to find segment coordinates from page data
                        const page = pagesData.find(p => p.pageNumber === sync.pageNumber);
                        if (page) {
                            customTextSegments.push({
                                id: sync.blockId,
                                pageNumber: sync.pageNumber,
                                text: sync.customText,
                                name: sync.notes || `Custom Segment`,
                                left: 0, // Will be recalculated if needed
                                top: 0,
                                width: 200,
                                height: 50
                            });
                        }
                    }
                });

                renderPagesList();
                renderPageSelect();
                if (pagesData.length > 0) {
                    selectPage(0);
                }
            } catch (error) {
                console.error('Error loading data:', error);
                alert('Error loading data: ' + error.message);
            }
        }

        function renderPagesList() {
            const pagesList = document.getElementById('pagesList');
            pagesList.innerHTML = '';
            pagesData.forEach((page, index) => {
                const pageItem = document.createElement('div');
                pageItem.className = `page-item ${index === currentPageIndex ? 'active' : ''}`;
                
                const thumbnailHtml = page.pdfPageImage 
                    ? `<img src="${page.pdfPageImage}" alt="Page ${page.pageNumber}">`
                    : `Page ${page.pageNumber}`;
                
                pageItem.innerHTML = `
                    <div class="page-thumbnail">${thumbnailHtml}</div>
                    <div class="page-number">Page ${page.pageNumber}</div>
                `;
                pageItem.onclick = () => selectPage(index);
                pagesList.appendChild(pageItem);
            });
        }

        function renderPageSelect() {
            const pageSelect = document.getElementById('pageSelect');
            pageSelect.innerHTML = '';
            pagesData.forEach((page, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = `Page ${page.pageNumber}`;
                pageSelect.appendChild(option);
            });
            pageSelect.onchange = (e) => selectPage(parseInt(e.target.value));
        }

        function selectPage(index) {
            currentPageIndex = index;
            const page = pagesData[index];
            
            document.getElementById('currentPageInfo').textContent = `Page ${page.pageNumber} of ${pagesData.length}`;
            document.getElementById('pageSelect').value = index;
            
            renderPdfCanvas(page);
            renderXhtmlPreview(page);
            renderPagesList();
            updateWaveformSegments();
        }

        function renderPdfCanvas(page) {
            const container = document.getElementById('pdfCanvasContainer');
            const blocks = page.textBlocks || [];
            
            if (!page.pdfPageImage) {
                container.innerHTML = '<p style="text-align: center; color: #999; padding: 40px;">No PDF page image available</p>';
                return;
            }

            let html = `
                <div class="pdf-page-container" id="pdfPageContainer">
                    <img src="${page.pdfPageImage}" alt="Page ${page.pageNumber}" class="pdf-page-image" id="pdfPageImage" 
                         onload="setupTextSelection()">
            `;

            // Add text blocks as overlays
            blocks.forEach((block, idx) => {
                const sync = audioSyncs.find(s => 
                    s.pageNumber === page.pageNumber && s.blockId === block.id
                );
                const isSelected = selectedBlockId === block.id;
                
                let style = '';
                if (block.coordinates) {
                    const coords = block.coordinates;
                    if (coords.top != null && coords.left != null) {
                        style = `position: absolute; top: ${coords.top}px; left: ${coords.left}px;`;
                        if (coords.width != null) style += ` width: ${coords.width}px;`;
                        if (coords.height != null) style += ` height: ${coords.height}px;`;
                    }
                }
                
                if (!style) {
                    style = `position: absolute; top: ${idx * 80 + 20}px; right: 20px; width: 300px;`;
                }

                html += `
                    <div class="text-block-overlay ${isSelected ? 'selected' : ''} ${sync ? 'synced' : ''}" 
                         onclick="selectBlockForSync('${block.id}', ${idx})"
                         data-block-id="${block.id}"
                         data-coords='${JSON.stringify(block.coordinates || {})}'
                         data-block-text="${escapeHtml(block.text)}"
                         style="${style}; cursor: pointer;"
                         title="Click to select for audio sync: ${escapeHtml(block.text.substring(0, 50))}...">
                        <div style="font-size: 11px; font-weight: 500; color: #000;">${escapeHtml(block.text.substring(0, 100))}${block.text.length > 100 ? '...' : ''}</div>
                    </div>
                `;
            });

            // Add custom text segments
            const pageCustomSegments = customTextSegments.filter(s => 
                s.pageNumber === page.pageNumber
            );
            pageCustomSegments.forEach((segment, idx) => {
                const style = `position: absolute; top: ${segment.top}px; left: ${segment.left}px; width: ${segment.width}px; height: ${segment.height}px;`;
                html += `
                    <div class="selected-text-segment" 
                         onclick="selectCustomSegment('${segment.id}')"
                         data-segment-id="${segment.id}"
                         style="${style}"
                         title="${escapeHtml(segment.text.substring(0, 50))}...">
                        <div style="font-size: 11px; font-weight: 500; color: #000;">${escapeHtml(segment.text.substring(0, 50))}${segment.text.length > 50 ? '...' : ''}</div>
                    </div>
                `;
            });

            html += '</div>';
            container.innerHTML = html;
            
            // Always setup text selection (click and drag)
            setupTextSelection();
        }

        function renderXhtmlPreview(page) {
            const container = document.getElementById('xhtmlPreviewContainer');
            const blocks = page.textBlocks || [];
            
            let html = '<div class="xhtml-content">';
            
            // Render regular text blocks
            if (blocks.length > 0) {
                blocks.forEach((block, idx) => {
                    const sync = audioSyncs.find(s => 
                        s.pageNumber === page.pageNumber && s.blockId === block.id
                    );
                    const isSelected = selectedBlockId === block.id;
                    const hasSync = sync && sync.startTime > 0 && sync.endTime > 0;
                    
                    html += `
                        <div class="xhtml-block ${isSelected ? 'selected' : ''}" data-block-id="${block.id}" id="block-${block.id}">
                            <div style="display: flex; justify-content: space-between; align-items: start;">
                                <div style="flex: 1;">
                                    <span class="block-tag" onclick="editBlockTag('${block.id}')">${block.tagName || 'p'}</span>
                                    <span style="display: block; margin-top: 8px; line-height: 1.6;">${escapeHtml(block.text)}</span>
                                </div>
                                <div class="block-actions" style="flex-shrink: 0; margin-left: 10px;">
                                    <button class="action-btn" onclick="selectBlockForSync('${block.id}', ${idx})" title="Select for audio sync">Select</button>
                                    <button class="action-btn" onclick="editBlock('${block.id}')">Edit</button>
                                </div>
                            </div>
                            ${hasSync ? `
                                <div style="margin-top: 12px; padding: 10px; background: #e3f2fd; border-radius: 4px; border-left: 3px solid #2196f3;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                        <span style="font-size: 12px; color: #1976d2; font-weight: 500;">
                                            Audio Sync: ${formatTime(sync.startTime)} - ${formatTime(sync.endTime)}
                                        </span>
                                        <button class="action-btn" style="background: #2196f3; color: white; padding: 4px 8px;" 
                                                onclick="playBlockAudio('${block.id}')">â–¶ Play</button>
                                    </div>
                                    <div style="position: relative;">
                                        <audio id="audio-${block.id}" style="width: 100%; height: 32px;" 
                                               data-start="${sync.startTime}" data-end="${sync.endTime}"
                                               preload="metadata" 
                                               onerror="handleAudioError('${block.id}')">
                                            <source src="${audioUrl}" type="audio/mpeg">
                                        </audio>
                                        <button onclick="generateTTSForBlock('${block.id}', ${page.pageNumber})" 
                                                style="position: absolute; right: 5px; top: 5px; padding: 4px 8px; 
                                                       background: #4caf50; color: white; border: none; border-radius: 3px; 
                                                       font-size: 10px; cursor: pointer; z-index: 10;"
                                                title="Generate TTS audio for this text">
                                            ðŸ”Š TTS
                                        </button>
                                    </div>
                                    <div style="display: flex; gap: 8px; margin-top: 8px;">
                                        <button class="action-btn" onclick="markStartTime()" style="font-size: 11px;">Mark Start (S)</button>
                                        <button class="action-btn" onclick="markEndTime()" style="font-size: 11px;">Mark End (E)</button>
                                    </div>
                                </div>
                            ` : `
                                <div style="margin-top: 12px; padding: 10px; background: #fff3e0; border-radius: 4px; border-left: 3px solid #ff9800;">
                                    <div style="font-size: 12px; color: #f57c00; margin-bottom: 8px;">
                                        Not synced - Generate TTS audio or mark start/end times
                                    </div>
                                    <div style="display: flex; gap: 8px;">
                                        <button class="action-btn" onclick="generateTTSForBlock('${block.id}', ${page.pageNumber})" 
                                                style="background: #4caf50; color: white;">ðŸ”Š Generate TTS</button>
                                        <button class="action-btn" onclick="selectBlockForSync('${block.id}', ${idx})" 
                                                style="background: #ff9800; color: white;">Select & Sync</button>
                                    </div>
                                </div>
                            `}
                        </div>
                    `;
                });
            }
            
            // Render custom text segments
            const pageCustomSegments = customTextSegments.filter(s => 
                s.pageNumber === page.pageNumber
            );
            pageCustomSegments.forEach((segment) => {
                const sync = audioSyncs.find(s => 
                    s.pageNumber === page.pageNumber && s.blockId === segment.id
                );
                const isSelected = selectedBlockId === segment.id;
                
                html += `
                    <div class="xhtml-block ${isSelected ? 'selected' : ''}" data-block-id="${segment.id}" style="border-left: 4px solid #ffc107;">
                        <div>
                            <span class="block-tag" style="background: #ffc107;">Custom</span>
                            <strong>${escapeHtml(segment.name)}</strong>
                        </div>
                        <div style="margin-top: 8px; padding: 8px; background: #fff9e6; border-radius: 4px;">
                            <span>${escapeHtml(segment.text.substring(0, 300))}${segment.text.length > 300 ? '...' : ''}</span>
                        </div>
                        <div class="block-actions" style="margin-top: 8px;">
                            ${sync && sync.startTime > 0 && sync.endTime > 0 ? 
                                `<span style="font-size: 11px; color: #2196f3;">Synced: ${formatTime(sync.startTime)} - ${formatTime(sync.endTime)}</span>` : 
                                '<span style="font-size: 11px; color: #ff9800;">Mark start and end times to sync</span>'
                            }
                            <button class="action-btn" onclick="deleteCustomSegment('${segment.id}')" style="background: #f44336; color: white; margin-left: 8px;">Delete</button>
                        </div>
                    </div>
                `;
            });
            
            if (blocks.length === 0 && pageCustomSegments.length === 0) {
                html += '<p style="text-align: center; color: #999; padding: 40px;">No text blocks found</p>';
            }
            
            html += '</div>';
            container.innerHTML = html;
        }

        function deleteCustomSegment(segmentId) {
            if (!confirm('Are you sure you want to delete this custom text segment?')) {
                return;
            }
            
            // Remove from custom segments
            customTextSegments = customTextSegments.filter(s => s.id !== segmentId);
            
            // Remove from audio syncs
            audioSyncs = audioSyncs.filter(s => s.blockId !== segmentId);
            
            // If it was selected, clear selection
            if (selectedBlockId === segmentId) {
                selectedBlockId = null;
            }
            
            const page = pagesData[currentPageIndex];
            renderPdfCanvas(page);
            renderXhtmlPreview(page);
            updateWaveformSegments();
        }

        function selectBlock(blockId, blockIndex) {
            selectedBlockId = blockId;
            const page = pagesData[currentPageIndex];
            renderPdfCanvas(page);
            renderXhtmlPreview(page);
            highlightWaveformSegment(blockId);
        }

        function selectBlockForSync(blockId, blockIndex) {
            // Direct selection - create sync entry immediately if not exists
            const page = pagesData[currentPageIndex];
            const block = page.textBlocks.find(b => b.id === blockId);
            
            if (!block) {
                // Check if it's a custom segment
                const customSegment = customTextSegments.find(s => s.id === blockId);
                if (customSegment) {
                    selectedBlockId = blockId;
                    renderPdfCanvas(page);
                    renderXhtmlPreview(page);
                    return;
                }
                return;
            }

            // Check if sync already exists
            let sync = audioSyncs.find(s => 
                s.pageNumber === page.pageNumber && s.blockId === blockId
            );

            if (!sync) {
                // Create new sync entry
                sync = {
                    pdfDocumentId: pdfId,
                    conversionJobId: jobId,
                    pageNumber: page.pageNumber,
                    blockId: blockId,
                    startTime: 0,
                    endTime: 0,
                    audioFilePath: audioUrl || '',
                    isCustomSegment: false
                };
                audioSyncs.push(sync);
            }

            // Select the block
            selectedBlockId = blockId;
            renderPdfCanvas(page);
            renderXhtmlPreview(page);
            updateWaveformSegments();
            
            // Scroll to the block in XHTML preview
            const blockElement = document.getElementById(`block-${blockId}`);
            if (blockElement) {
                blockElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                blockElement.style.border = '3px solid #2196f3';
                setTimeout(() => {
                    blockElement.style.border = '';
                }, 2000);
            }
            
            // Show helpful message
            if (sync.startTime === 0 && sync.endTime === 0) {
                setTimeout(() => {
                    // Don't show alert, just highlight the sync controls
                    const syncDiv = blockElement?.querySelector('[style*="background: #fff3e0"]');
                    if (syncDiv) {
                        syncDiv.style.animation = 'pulse 2s ease-in-out';
                        setTimeout(() => {
                            syncDiv.style.animation = '';
                        }, 2000);
                    }
                }, 100);
            }
        }

        function initializeWaveform() {
            waveformCanvas = document.getElementById('waveformCanvas');
            waveformCtx = waveformCanvas.getContext('2d');
            
            // Resize canvas
            const container = document.getElementById('waveformContainer');
            waveformCanvas.width = container.offsetWidth;
            waveformCanvas.height = container.offsetHeight - 40;
            
            // Draw waveform (will be updated when audio loads)
            drawWaveform();
        }

        async function loadAudioForWaveform() {
            if (!audioUrl || !audioPlayer) return;
            
            try {
                // Create AudioContext if not exists
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                // Fetch audio file
                const response = await fetch(audioUrl);
                const arrayBuffer = await response.arrayBuffer();
                
                // Decode audio data
                audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                
                // Generate waveform data from audio buffer
                generateWaveformData();
                
                // Draw the waveform
                drawWaveform();
                
            } catch (error) {
                console.error('Error loading audio for waveform:', error);
                // Draw placeholder if audio loading fails
                drawPlaceholderWaveform();
            }
        }

        function generateWaveformData() {
            if (!audioBuffer) return;
            
            const samples = 2000; // Number of data points to extract
            const blockSize = Math.floor(audioBuffer.length / samples);
            const data = [];
            
            // Get channel data (use first channel)
            const channelData = audioBuffer.getChannelData(0);
            
            for (let i = 0; i < samples; i++) {
                let sum = 0;
                const start = i * blockSize;
                const end = Math.min(start + blockSize, channelData.length);
                
                // Calculate RMS (Root Mean Square) for this block
                for (let j = start; j < end; j++) {
                    sum += channelData[j] * channelData[j];
                }
                
                const rms = Math.sqrt(sum / (end - start));
                data.push(rms);
            }
            
            waveformData = data;
        }

        function drawWaveform() {
            if (!waveformCtx || !waveformCanvas) return;
            
            const width = waveformCanvas.width;
            const height = waveformCanvas.height;
            
            // Clear canvas
            waveformCtx.fillStyle = '#1a1a1a';
            waveformCtx.fillRect(0, 0, width, height);
            
            if (waveformData && waveformData.length > 0) {
                // Draw actual waveform from audio data
                waveformCtx.strokeStyle = '#4caf50';
                waveformCtx.lineWidth = 2;
                waveformCtx.beginPath();
                
                const centerY = height / 2;
                const step = width / waveformData.length;
                
                for (let i = 0; i < waveformData.length; i++) {
                    const x = i * step;
                    // Scale amplitude to fit canvas height
                    const amplitude = waveformData[i] * height * 0.4; // 40% of height
                    const y1 = centerY - amplitude;
                    const y2 = centerY + amplitude;
                    
                    if (i === 0) {
                        waveformCtx.moveTo(x, centerY);
                    }
                    
                    // Draw line from center to top
                    waveformCtx.lineTo(x, y1);
                    // Draw line back to center
                    waveformCtx.lineTo(x, centerY);
                    // Draw line to bottom
                    waveformCtx.lineTo(x, y2);
                    // Draw line back to center
                    waveformCtx.lineTo(x, centerY);
                }
                
                waveformCtx.stroke();
                
                // Draw center line
                waveformCtx.strokeStyle = '#666';
                waveformCtx.lineWidth = 1;
                waveformCtx.beginPath();
                waveformCtx.moveTo(0, centerY);
                waveformCtx.lineTo(width, centerY);
                waveformCtx.stroke();
                
            } else {
                // Draw placeholder if no audio data
                drawPlaceholderWaveform();
            }
            
            // Draw segment boundaries
            updateWaveformSegments();
        }

        function drawPlaceholderWaveform() {
            if (!waveformCtx || !waveformCanvas) return;
            
            const width = waveformCanvas.width;
            const height = waveformCanvas.height;
            const centerY = height / 2;
            
            // Draw placeholder message
            waveformCtx.fillStyle = '#666';
            waveformCtx.font = '14px Arial';
            waveformCtx.textAlign = 'center';
            waveformCtx.fillText('Loading audio waveform...', width / 2, centerY);
            
            // Draw simple placeholder waveform
            waveformCtx.strokeStyle = '#4caf50';
            waveformCtx.lineWidth = 2;
            waveformCtx.beginPath();
            
            for (let x = 0; x < width; x += 2) {
                const amplitude = Math.random() * (height / 2 - 20);
                const y = centerY + (Math.random() > 0.5 ? amplitude : -amplitude);
                if (x === 0) {
                    waveformCtx.moveTo(x, y);
                } else {
                    waveformCtx.lineTo(x, y);
                }
            }
            waveformCtx.stroke();
        }

        function updateWaveformSegments() {
            if (!waveformCanvas) return;
            
            const page = pagesData[currentPageIndex];
            if (!page) return;
            
            // Use audioBuffer duration if available, otherwise use audioPlayer duration
            const duration = (audioBuffer ? audioBuffer.duration : (audioPlayer ? audioPlayer.duration : 0)) || 0;
            if (duration === 0) return;
            
            const width = waveformCanvas.width;
            const container = document.getElementById('waveformContainer');
            
            // Remove existing boundaries
            const existing = container.querySelectorAll('.segment-boundary, .segment-label');
            existing.forEach(el => el.remove());
            
            // Add boundaries for each synced block (regular blocks)
            page.textBlocks.forEach(block => {
                const sync = audioSyncs.find(s => 
                    s.pageNumber === page.pageNumber && s.blockId === block.id
                );
                
                if (sync && sync.startTime != null && sync.endTime != null && sync.startTime > 0 && sync.endTime > 0) {
                    const startX = (sync.startTime / duration) * width;
                    const endX = (sync.endTime / duration) * width;
                    
                    // Start boundary
                    const startBoundary = document.createElement('div');
                    startBoundary.className = 'segment-boundary start';
                    startBoundary.style.left = startX + 'px';
                    startBoundary.dataset.blockId = block.id;
                    startBoundary.dataset.type = 'start';
                    startBoundary.onmousedown = (e) => startDragBoundary(e, block.id, 'start');
                    container.appendChild(startBoundary);
                    
                    // End boundary
                    const endBoundary = document.createElement('div');
                    endBoundary.className = 'segment-boundary end';
                    endBoundary.style.left = endX + 'px';
                    endBoundary.dataset.blockId = block.id;
                    endBoundary.dataset.type = 'end';
                    endBoundary.onmousedown = (e) => startDragBoundary(e, block.id, 'end');
                    container.appendChild(endBoundary);
                    
                    // Label
                    const label = document.createElement('div');
                    label.className = 'segment-label';
                    label.style.left = (startX + (endX - startX) / 2) + 'px';
                    label.textContent = block.text.substring(0, 20) + '...';
                    container.appendChild(label);
                }
            });
            
            // Add boundaries for custom segments
            const pageCustomSegments = customTextSegments.filter(s => 
                s.pageNumber === page.pageNumber
            );
            pageCustomSegments.forEach(segment => {
                const sync = audioSyncs.find(s => 
                    s.pageNumber === page.pageNumber && s.blockId === segment.id
                );
                
                if (sync && sync.startTime != null && sync.endTime != null && sync.startTime > 0 && sync.endTime > 0) {
                    const startX = (sync.startTime / duration) * width;
                    const endX = (sync.endTime / duration) * width;
                    
                    // Start boundary (custom segments use different color)
                    const startBoundary = document.createElement('div');
                    startBoundary.className = 'segment-boundary start';
                    startBoundary.style.background = '#ffc107';
                    startBoundary.style.left = startX + 'px';
                    startBoundary.dataset.blockId = segment.id;
                    startBoundary.dataset.type = 'start';
                    startBoundary.onmousedown = (e) => startDragBoundary(e, segment.id, 'start');
                    container.appendChild(startBoundary);
                    
                    // End boundary
                    const endBoundary = document.createElement('div');
                    endBoundary.className = 'segment-boundary end';
                    endBoundary.style.background = '#ff9800';
                    endBoundary.style.left = endX + 'px';
                    endBoundary.dataset.blockId = segment.id;
                    endBoundary.dataset.type = 'end';
                    endBoundary.onmousedown = (e) => startDragBoundary(e, segment.id, 'end');
                    container.appendChild(endBoundary);
                    
                    // Label
                    const label = document.createElement('div');
                    label.className = 'segment-label';
                    label.style.left = (startX + (endX - startX) / 2) + 'px';
                    label.textContent = segment.name || segment.text.substring(0, 20) + '...';
                    label.style.background = 'rgba(255, 193, 7, 0.9)';
                    container.appendChild(label);
                }
            });
        }

        function highlightWaveformSegment(blockId) {
            const page = pagesData[currentPageIndex];
            const sync = audioSyncs.find(s => 
                s.pageNumber === page.pageNumber && s.blockId === blockId
            );
            
            if (sync && audioPlayer) {
                audioPlayer.currentTime = sync.startTime;
                audioPlayer.play();
            }
        }

        function playBlockAudio(blockId) {
            const page = pagesData[currentPageIndex];
            const sync = audioSyncs.find(s => 
                s.pageNumber === page.pageNumber && s.blockId === blockId
            );
            
            if (sync && sync.startTime > 0 && sync.endTime > 0) {
                // Use the main audio player
                if (audioPlayer) {
                    audioPlayer.currentTime = sync.startTime;
                    audioPlayer.play();
                    
                    // Stop at end time
                    const checkEnd = setInterval(() => {
                        if (audioPlayer.currentTime >= sync.endTime || audioPlayer.paused) {
                            audioPlayer.pause();
                            clearInterval(checkEnd);
                        }
                    }, 100);
                }
                
                // Also try to use the block-specific audio element if it exists
                const blockAudio = document.getElementById(`audio-${blockId}`);
                if (blockAudio) {
                    blockAudio.currentTime = sync.startTime;
                    blockAudio.play().catch(err => {
                        console.error('Error playing block audio:', err);
                        // Try to generate TTS if audio fails
                        const block = page.textBlocks.find(b => b.id === blockId);
                        if (block) {
                            generateTTSForBlock(blockId, page.pageNumber);
                        }
                    });
                    
                    const checkEndBlock = setInterval(() => {
                        if (blockAudio.currentTime >= sync.endTime || blockAudio.paused) {
                            blockAudio.pause();
                            clearInterval(checkEndBlock);
                        }
                    }, 100);
                }
            } else {
                // Try to generate TTS audio if not synced
                const block = page.textBlocks.find(b => b.id === blockId);
                if (block && block.text) {
                    if (confirm('This text block is not synced yet. Would you like to generate TTS audio for it?')) {
                        generateTTSForBlock(blockId, page.pageNumber);
                    }
                } else {
                    alert('This text block is not synced yet. Please mark start and end times first.');
                }
            }
        }

        async function generateTTSForBlock(blockId, pageNumber) {
            const page = pagesData[currentPageIndex];
            const block = page.textBlocks.find(b => b.id === blockId);
            
            if (!block || !block.text) {
                alert('No text found for this block');
                return;
            }
            
            // Try browser's Web Speech API first (better quality, real TTS)
            if ('speechSynthesis' in window) {
                try {
                    // Use browser's built-in TTS
                    const utterance = new SpeechSynthesisUtterance(block.text);
                    
                    // Set voice based on preference
                    const voices = speechSynthesis.getVoices();
                    if (voicePreference === 'kid-friendly' || voicePreference === 'child' || voicePreference === 'young') {
                        // Try to find a child-friendly voice
                        const kidVoice = voices.find(v => 
                            v.name.toLowerCase().includes('child') || 
                            v.name.toLowerCase().includes('young') ||
                            v.name.toLowerCase().includes('high') ||
                            (v.lang.startsWith('en') && v.name.toLowerCase().includes('female'))
                        );
                        if (kidVoice) {
                            utterance.voice = kidVoice;
                        }
                    }
                    
                    utterance.rate = 0.9; // Slightly slower for kids
                    utterance.pitch = 1.2; // Higher pitch for kid-friendly
                    utterance.volume = 1.0;
                    
                    // Show playing indicator
                    const blockElement = document.getElementById(`block-${blockId}`);
                    const playingMsg = document.createElement('div');
                    playingMsg.id = `tts-playing-${blockId}`;
                    playingMsg.style.cssText = 'padding: 10px; background: #e3f2fd; border-radius: 4px; margin-top: 8px; color: #1976d2;';
                    playingMsg.textContent = 'ðŸ”Š Playing TTS audio...';
                    blockElement?.appendChild(playingMsg);
                    
                    utterance.onend = () => {
                        const playing = document.getElementById(`tts-playing-${blockId}`);
                        if (playing) playing.remove();
                    };
                    
                    utterance.onerror = (e) => {
                        console.error('Speech synthesis error:', e);
                        const playing = document.getElementById(`tts-playing-${blockId}`);
                        if (playing) playing.remove();
                        // Fall back to server-side TTS
                        generateServerTTS(blockId, pageNumber, block.text);
                    };
                    
                    speechSynthesis.speak(utterance);
                    return;
                } catch (e) {
                    console.warn('Browser TTS failed, falling back to server TTS:', e);
                }
            }
            
            // Fall back to server-side TTS generation
            generateServerTTS(blockId, pageNumber, block.text);
        }
        
        async function generateServerTTS(blockId, pageNumber, text) {
            try {
                // Show loading indicator
                const blockElement = document.getElementById(`block-${blockId}`);
                const loadingMsg = document.createElement('div');
                loadingMsg.id = `tts-loading-${blockId}`;
                loadingMsg.style.cssText = 'padding: 10px; background: #fff9c4; border-radius: 4px; margin-top: 8px;';
                loadingMsg.textContent = 'Generating TTS audio...';
                blockElement?.appendChild(loadingMsg);
                
                // Call TTS generation endpoint
                const response = await fetch(`/api/audio-sync/job/${jobId}/generate-tts`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        text: text,
                        blockId: blockId,
                        pageNumber: pageNumber,
                        voice: voicePreference
                    })
                });
                
                if (response.ok) {
                    // Get audio blob URL
                    const audioBlob = await response.blob();
                    const audioUrl = URL.createObjectURL(audioBlob);
                    
                    // Update audio element
                    const blockAudio = document.getElementById(`audio-${blockId}`);
                    if (blockAudio) {
                        blockAudio.src = audioUrl;
                        blockAudio.load();
                        
                        // Auto-play the generated audio
                        blockAudio.play().catch(err => {
                            console.error('Error playing generated TTS:', err);
                        });
                    }
                    
                    // Remove loading indicator
                    const loading = document.getElementById(`tts-loading-${blockId}`);
                    if (loading) loading.remove();
                    
                    // Show success message
                    const successMsg = document.createElement('div');
                    successMsg.style.cssText = 'padding: 10px; background: #c8e6c9; border-radius: 4px; margin-top: 8px; color: #2e7d32;';
                    successMsg.textContent = 'âœ“ TTS audio generated successfully!';
                    blockElement?.appendChild(successMsg);
                    
                    setTimeout(() => {
                        successMsg.remove();
                    }, 3000);
                    
                } else {
                    const errorText = await response.text();
                    let errorMsg = 'Failed to generate TTS audio';
                    try {
                        const error = JSON.parse(errorText);
                        errorMsg = error.error || errorMsg;
                    } catch (e) {
                        errorMsg = errorText || errorMsg;
                    }
                    throw new Error(errorMsg);
                }
            } catch (error) {
                console.error('Error generating TTS:', error);
                alert('Error generating TTS audio: ' + error.message);
                
                // Remove loading indicator
                const loading = document.getElementById(`tts-loading-${blockId}`);
                if (loading) loading.remove();
            }
        }

        let isDragging = false;
        let dragBoundary = null;
        let dragType = null;

        function startDragBoundary(e, blockId, type) {
            e.preventDefault();
            isDragging = true;
            dragBoundary = blockId;
            dragType = type;
            
            document.onmousemove = (e) => {
                if (!isDragging) return;
                const container = document.getElementById('waveformContainer');
                const rect = container.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const percent = Math.max(0, Math.min(1, x / rect.width));
                
                const duration = audioPlayer.duration || 0;
                const time = percent * duration;
                
                // Update boundary position
                const boundary = e.target;
                boundary.style.left = x + 'px';
                
                // Update sync time
                updateSyncTime(blockId, type, time);
            };
            
            document.onmouseup = () => {
                isDragging = false;
                document.onmousemove = null;
                document.onmouseup = null;
                logEdit('boundary_drag', { blockId, type, time: dragType === 'start' ? 'startTime' : 'endTime' });
            };
        }

        function updateSyncTime(blockId, type, time) {
            const page = pagesData[currentPageIndex];
            let sync = audioSyncs.find(s => 
                s.pageNumber === page.pageNumber && s.blockId === blockId
            );
            
            if (!sync) {
                sync = {
                    pdfDocumentId: pdfId,
                    conversionJobId: jobId,
                    pageNumber: page.pageNumber,
                    blockId: blockId,
                    startTime: 0,
                    endTime: 0
                };
                audioSyncs.push(sync);
            }
            
            if (type === 'start') {
                sync.startTime = time;
            } else {
                sync.endTime = time;
            }
        }

        function editBlock(blockId) {
            const page = pagesData[currentPageIndex];
            const block = page.textBlocks.find(b => b.id === blockId);
            if (!block) return;
            
            document.getElementById('modalTitle').textContent = 'Edit Block';
            document.getElementById('blockTagSelect').value = block.tagName || 'p';
            document.getElementById('textContentInput').value = block.text;
            document.getElementById('altTextInput').value = '';
            
            document.getElementById('editModal').classList.add('active');
            document.getElementById('editModal').dataset.blockId = blockId;
        }

        function editBlockTag(blockId) {
            editBlock(blockId);
        }

        function editAltText(blockId) {
            const page = pagesData[currentPageIndex];
            const block = page.textBlocks.find(b => b.id === blockId);
            if (!block) return;
            
            document.getElementById('modalTitle').textContent = 'Edit Alt Text';
            document.getElementById('altTextInput').value = '';
            document.getElementById('textContentInput').value = '';
            
            document.getElementById('editModal').classList.add('active');
            document.getElementById('editModal').dataset.blockId = blockId;
        }

        function saveBlockEdit() {
            const blockId = document.getElementById('editModal').dataset.blockId;
            const page = pagesData[currentPageIndex];
            const block = page.textBlocks.find(b => b.id === blockId);
            
            if (!block) return;
            
            const newTag = document.getElementById('blockTagSelect').value;
            const newText = document.getElementById('textContentInput').value;
            const newAltText = document.getElementById('altTextInput').value;
            
            // Update block
            if (newTag) block.tagName = newTag;
            if (newText) block.text = newText;
            
            logEdit('block_edit', { blockId, tag: newTag, text: newText, altText: newAltText });
            
            closeModal();
            renderXhtmlPreview(page);
            renderPdfCanvas(page);
        }

        function closeModal() {
            document.getElementById('editModal').classList.remove('active');
        }

        function reRunAlignment() {
            if (!selectedBlockId) {
                alert('Please select a block first');
                return;
            }
            
            const page = pagesData[currentPageIndex];
            const block = page.textBlocks.find(b => b.id === selectedBlockId);
            
            if (!block) return;
            
            // Call backend to re-run alignment
            fetch(`/api/audio-sync/job/${jobId}/realign`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ blockId: selectedBlockId, text: block.text })
            }).then(response => {
                if (response.ok) {
                    alert('Re-alignment completed');
                    loadData();
                } else {
                    alert('Re-alignment failed');
                }
            });
            
            logEdit('realign', { blockId: selectedBlockId });
        }

        function markStartTime() {
            if (!selectedBlockId) {
                alert('Please select a text block or custom segment first');
                return;
            }
            
            if (!audioPlayer) {
                alert('Audio not loaded');
                return;
            }
            
            const currentTime = audioPlayer.currentTime;
            updateSyncTime(selectedBlockId, 'start', currentTime);
            
            const page = pagesData[currentPageIndex];
            renderPdfCanvas(page);
            renderXhtmlPreview(page);
            updateWaveformSegments();
            
            logEdit('mark_start', { blockId: selectedBlockId, time: currentTime });
        }

        function markEndTime() {
            if (!selectedBlockId) {
                alert('Please select a text block or custom segment first');
                return;
            }
            
            if (!audioPlayer) {
                alert('Audio not loaded');
                return;
            }
            
            const currentTime = audioPlayer.currentTime;
            updateSyncTime(selectedBlockId, 'end', currentTime);
            
            const page = pagesData[currentPageIndex];
            renderPdfCanvas(page);
            renderXhtmlPreview(page);
            updateWaveformSegments();
            
            logEdit('mark_end', { blockId: selectedBlockId, time: currentTime });
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Don't trigger if typing in an input field
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }
            
            if (e.key === 's' || e.key === 'S') {
                e.preventDefault();
                markStartTime();
            } else if (e.key === 'e' || e.key === 'E') {
                e.preventDefault();
                markEndTime();
            }
        });

        function updateVoicePreference() {
            voicePreference = document.getElementById('voiceSelect').value;
            // Store preference for TTS generation
            localStorage.setItem('audioSyncVoicePreference', voicePreference);
        }

        function saveAllChanges() {
            // Save all syncs (including custom segments)
            const promises = audioSyncs.map(sync => {
                // Add custom text if it's a custom segment
                if (sync.isCustomSegment) {
                    const segment = customTextSegments.find(s => s.id === sync.blockId);
                    if (segment) {
                        sync.customText = segment.text;
                    }
                }
                
                // Add voice preference to notes
                if (!sync.notes) {
                    sync.notes = '';
                }
                if (voicePreference !== 'default') {
                    sync.notes = (sync.notes ? sync.notes + ' | ' : '') + 'Voice: ' + voicePreference;
                }
                
                return fetch('/api/audio-sync', {
                    method: sync.id ? 'PUT' : 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(sync)
                });
            });
            
            Promise.all(promises).then(() => {
                // Send edit log with voice preference
                fetch(`/api/audio-sync/job/${jobId}/edit-log`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        edits: editLog,
                        voicePreference: voicePreference
                    })
                }).then(() => {
                    alert('All changes saved successfully!\n\nVoice preference: ' + voicePreference);
                    editLog = [];
                    // Reload syncs to get updated IDs
                    loadData();
                });
            }).catch(error => {
                console.error('Error saving changes:', error);
                alert('Error saving changes: ' + error.message);
            });
        }

        function logEdit(action, data) {
            editLog.push({
                timestamp: new Date().toISOString(),
                action,
                data,
                pageNumber: pagesData[currentPageIndex]?.pageNumber,
                blockId: selectedBlockId
            });
        }

        function toggleHighlightMode() {
            // Toggle highlight visibility
            const overlays = document.querySelectorAll('.text-block-overlay');
            overlays.forEach(overlay => {
                overlay.style.display = overlay.style.display === 'none' ? 'block' : 'none';
            });
        }

        function setupTextSelection() {
            const container = document.getElementById('pdfPageContainer');
            if (!container) return;

            // Remove existing listeners to avoid duplicates
            cleanupTextSelection();

            // Allow both click-to-select blocks and drag-to-select custom areas
            container.style.cursor = 'default';
            
            // Only add drag selection on empty areas (not on text blocks)
            container.addEventListener('mousedown', startTextSelection, true);
            container.addEventListener('mousemove', updateTextSelection);
            container.addEventListener('mouseup', endTextSelection);
            container.addEventListener('mouseleave', cancelTextSelection);
        }

        function cleanupTextSelection() {
            const container = document.getElementById('pdfPageContainer');
            if (!container) return;

            container.style.cursor = '';
            container.removeEventListener('mousedown', startTextSelection);
            container.removeEventListener('mousemove', updateTextSelection);
            container.removeEventListener('mouseup', endTextSelection);
            container.removeEventListener('mouseleave', cancelTextSelection);

            if (selectionRectangle) {
                selectionRectangle.remove();
                selectionRectangle = null;
            }
            isSelecting = false;
            selectionStart = null;
        }

        function startTextSelection(e) {
            // Don't start selection if clicking on a text block overlay
            if (e.target.closest('.text-block-overlay') || e.target.closest('.selected-text-segment')) {
                return;
            }

            e.preventDefault();
            e.stopPropagation();

            const container = document.getElementById('pdfPageContainer');
            if (!container) return;

            const rect = container.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            isSelecting = true;
            selectionStart = { x, y };

            // Create selection rectangle
            selectionRectangle = document.createElement('div');
            selectionRectangle.className = 'selection-rectangle';
            selectionRectangle.style.left = x + 'px';
            selectionRectangle.style.top = y + 'px';
            selectionRectangle.style.width = '0px';
            selectionRectangle.style.height = '0px';
            container.appendChild(selectionRectangle);
        }

        function updateTextSelection(e) {
            if (!isSelecting || !selectionStart) return;

            const container = document.getElementById('pdfPageContainer');
            if (!container || !selectionRectangle) return;

            const rect = container.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const currentY = e.clientY - rect.top;

            const left = Math.min(selectionStart.x, currentX);
            const top = Math.min(selectionStart.y, currentY);
            const width = Math.abs(currentX - selectionStart.x);
            const height = Math.abs(currentY - selectionStart.y);

            selectionRectangle.style.left = left + 'px';
            selectionRectangle.style.top = top + 'px';
            selectionRectangle.style.width = width + 'px';
            selectionRectangle.style.height = height + 'px';
        }

        function endTextSelection(e) {
            if (!isSelecting || !selectionStart) return;

            const container = document.getElementById('pdfPageContainer');
            if (!container || !selectionRectangle) return;

            const rect = container.getBoundingClientRect();
            const endX = e.clientX - rect.left;
            const endY = e.clientY - rect.top;

            const left = Math.min(selectionStart.x, endX);
            const top = Math.min(selectionStart.y, endY);
            const width = Math.abs(endX - selectionStart.x);
            const height = Math.abs(endY - selectionStart.y);

            // Only process if selection is meaningful (at least 20x20 pixels)
            if (width > 20 && height > 20) {
                findTextInSelection(left, top, width, height);
            }

            // Cleanup
            selectionRectangle.remove();
            selectionRectangle = null;
            isSelecting = false;
            selectionStart = null;
        }

        function cancelTextSelection() {
            if (selectionRectangle) {
                selectionRectangle.remove();
                selectionRectangle = null;
            }
            isSelecting = false;
            selectionStart = null;
        }

        function findTextInSelection(selLeft, selTop, selWidth, selHeight) {
            const page = pagesData[currentPageIndex];
            if (!page || !page.textBlocks) return;

            const selectedBlocks = [];
            const container = document.getElementById('pdfPageContainer');
            const img = document.getElementById('pdfPageImage');
            
            if (!img || !container) return;

            // Get image dimensions and calculate scale
            const imgRect = img.getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();
            
            // Calculate scale factor if image is scaled
            const imgNaturalWidth = img.naturalWidth;
            const imgNaturalHeight = img.naturalHeight;
            const imgDisplayWidth = imgRect.width;
            const imgDisplayHeight = imgRect.height;
            
            const scaleX = imgNaturalWidth / imgDisplayWidth;
            const scaleY = imgNaturalHeight / imgDisplayHeight;

            // Convert selection coordinates to image coordinates
            const imgLeft = selLeft * scaleX;
            const imgTop = selTop * scaleY;
            const imgWidth = selWidth * scaleX;
            const imgHeight = selHeight * scaleY;

            // Find text blocks that intersect with selection using extracted text blocks
            // This works even if text is behind images because we use the extracted text block coordinates
            page.textBlocks.forEach(block => {
                if (!block.coordinates) {
                    // If no coordinates, try to match by checking if block text is visible in selection area
                    // This is a fallback for blocks without precise coordinates
                    return;
                }

                const coords = block.coordinates;
                const blockLeft = coords.left || 0;
                const blockTop = coords.top || 0;
                const blockWidth = coords.width || 0;
                const blockHeight = coords.height || 0;
                const blockRight = blockLeft + blockWidth;
                const blockBottom = blockTop + blockHeight;

                const selRight = imgLeft + imgWidth;
                const selBottom = imgTop + imgHeight;

                // Check if blocks intersect (using extracted coordinates, not visual)
                if (!(blockRight < imgLeft || blockLeft > selRight || 
                      blockBottom < imgTop || blockTop > selBottom)) {
                    selectedBlocks.push(block);
                }
            });

            if (selectedBlocks.length > 0) {
                // Combine text from selected blocks
                const combinedText = selectedBlocks.map(b => b.text).join(' ').trim();
                
                // Automatically create custom segment
                createCustomSegmentFromSelection(combinedText, selLeft, selTop, selWidth, selHeight, selectedBlocks);
            } else {
                // Show helpful message with option to select from list
                if (confirm('No text found in the selected area.\n\nWould you like to select from the text blocks list on the right?')) {
                    // Scroll to first block in XHTML preview
                    const firstBlock = document.querySelector('.xhtml-block');
                    if (firstBlock) {
                        firstBlock.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        firstBlock.style.border = '3px solid #ff9800';
                        setTimeout(() => {
                            firstBlock.style.border = '';
                        }, 2000);
                    }
                }
            }
        }

        function createCustomSegmentFromSelection(text, left, top, width, height, blocks) {
            if (!text || text.trim().length === 0) {
                alert('No text selected');
                return;
            }

            const page = pagesData[currentPageIndex];
            const segmentId = 'custom_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            
            // Create custom segment object
            const customSegment = {
                id: segmentId,
                pageNumber: page.pageNumber,
                text: text,
                left: left,
                top: top,
                width: width,
                height: height,
                name: `Custom Selection ${customTextSegments.filter(s => s.pageNumber === page.pageNumber).length + 1}`,
                blockIds: blocks.map(b => b.id)
            };

            customTextSegments.push(customSegment);
            
            // Create audio sync entry (will be saved when user marks start/end time)
            const sync = {
                pdfDocumentId: pdfId,
                conversionJobId: jobId,
                pageNumber: page.pageNumber,
                blockId: segmentId,
                startTime: 0,
                endTime: 0,
                customText: text,
                isCustomSegment: true,
                audioFilePath: audioUrl || ''
            };
            audioSyncs.push(sync);

            // Re-render canvas to show new segment
            renderPdfCanvas(page);

            // Select the new segment
            selectedBlockId = segmentId;
            renderXhtmlPreview(page);
            updateWaveformSegments();
            
            // Show helpful message
            setTimeout(() => {
                alert(`Custom text selection created!\n\n"${text.substring(0, 100)}${text.length > 100 ? '...' : ''}"\n\nNow use "Mark Start" (S key) and "Mark End" (E key) to set the audio timing for this text.`);
            }, 100);
        }

        function selectCustomSegment(segmentId) {
            selectedBlockId = segmentId;
            const page = pagesData[currentPageIndex];
            renderPdfCanvas(page);
            renderXhtmlPreview(page);
            highlightWaveformSegment(segmentId);
        }

        function toggleXhtmlView() {
            // Toggle between code and preview view
            const container = document.getElementById('xhtmlPreviewContainer');
            if (container.classList.contains('code-view')) {
                container.classList.remove('code-view');
                renderXhtmlPreview(pagesData[currentPageIndex]);
            } else {
                container.classList.add('code-view');
                const page = pagesData[currentPageIndex];
                container.innerHTML = `<pre class="xhtml-content">${escapeHtml(page.fullHtml || '')}</pre>`;
            }
        }

        function updateTimeDisplay() {
            if (!audioPlayer) return;
            const current = audioPlayer.currentTime;
            const duration = audioPlayer.duration || 0;
            document.getElementById('timeDisplay').textContent = 
                `${formatTime(current)} / ${formatTime(duration)}`;
            const percent = duration > 0 ? (current / duration) * 100 : 0;
            document.getElementById('progressFill').style.width = percent + '%';
        }

        function formatTime(seconds) {
            if (!seconds) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function handleAudioError(blockId) {
            console.error('Audio playback error for block:', blockId);
            // Try to generate TTS if audio fails
            const page = pagesData[currentPageIndex];
            const block = page.textBlocks.find(b => b.id === blockId);
            if (block && block.text) {
                console.log('Attempting to generate TTS for block:', blockId);
                generateTTSForBlock(blockId, page.pageNumber);
            }
        }

        // Event listeners
        document.getElementById('playBtn').onclick = () => {
            if (audioPlayer.paused) {
                audioPlayer.play();
                document.getElementById('playBtn').textContent = 'â¸';
            } else {
                audioPlayer.pause();
                document.getElementById('playBtn').textContent = 'â–¶';
            }
        };

        document.getElementById('progressBar').onclick = (e) => {
            const rect = e.currentTarget.getBoundingClientRect();
            const percent = (e.clientX - rect.left) / rect.width;
            const duration = (audioBuffer ? audioBuffer.duration : audioPlayer.duration) || 0;
            if (duration > 0) {
                audioPlayer.currentTime = percent * duration;
                updateWaveformPlaybackPosition();
            }
        };

        // Allow clicking on waveform to seek
        document.getElementById('waveformCanvas')?.addEventListener('click', (e) => {
            if (!audioPlayer || !waveformCanvas) return;
            
            const rect = waveformCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const width = waveformCanvas.width;
            const duration = (audioBuffer ? audioBuffer.duration : audioPlayer.duration) || 0;
            
            if (duration > 0) {
                const percent = x / width;
                audioPlayer.currentTime = percent * duration;
                updateWaveformPlaybackPosition();
            }
        });

        // Window resize
        window.onresize = () => {
            if (waveformCanvas) {
                const container = document.getElementById('waveformContainer');
                waveformCanvas.width = container.offsetWidth;
                waveformCanvas.height = container.offsetHeight - 40;
                drawWaveform();
                updateWaveformSegments();
            }
        };

        // Update waveform when audio time changes (show playback position)
        function updateWaveformPlaybackPosition() {
            if (!waveformCtx || !waveformCanvas || !audioPlayer) return;
            
            const width = waveformCanvas.width;
            const height = waveformCanvas.height;
            const duration = (audioBuffer ? audioBuffer.duration : audioPlayer.duration) || 0;
            
            if (duration > 0 && audioPlayer.currentTime >= 0) {
                const currentTime = audioPlayer.currentTime;
                const positionX = (currentTime / duration) * width;
                
                // Redraw waveform
                drawWaveform();
                
                // Draw playback position indicator (red line)
                waveformCtx.strokeStyle = '#ff5722';
                waveformCtx.lineWidth = 3;
                waveformCtx.beginPath();
                waveformCtx.moveTo(positionX, 0);
                waveformCtx.lineTo(positionX, height);
                waveformCtx.stroke();
                
                // Draw a small circle at the position
                waveformCtx.fillStyle = '#ff5722';
                waveformCtx.beginPath();
                waveformCtx.arc(positionX, height / 2, 5, 0, 2 * Math.PI);
                waveformCtx.fill();
            }
        }

        // Load voices for Web Speech API
        if ('speechSynthesis' in window) {
            // Chrome loads voices asynchronously
            speechSynthesis.onvoiceschanged = () => {
                console.log('Voices loaded:', speechSynthesis.getVoices().length);
            };
            // Also try immediately in case voices are already loaded
            if (speechSynthesis.getVoices().length > 0) {
                console.log('Voices already available:', speechSynthesis.getVoices().length);
            }
        }

        // Initialize
        loadData();
    </script>
</body>
</html>
